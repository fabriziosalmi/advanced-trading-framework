"""
Advanced Trading Framework - Trading Signals

This module defines the standard data structure for trading signals,
providing a consistent interface for signal generation across all strategies.

Author: Senior Python Software Architect
Version: 1.0.0
"""

from dataclasses import dataclass
from typing import Optional, Dict, Any
from enum import Enum
import time


class ActionType(Enum):
    """Enumeration for trading actions."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


@dataclass
class TradingSignal:
    """
    Standard data structure for trading signals.
    
    This dataclass provides a consistent interface for all trading signals
    generated by strategies, ensuring compatibility across the framework.
    
    Attributes:
        ticker: Stock symbol (e.g., 'AAPL')
        action: Trading action ('BUY', 'SELL', or 'HOLD')
        confidence: Confidence level from 0.0 to 1.0
        timestamp: Unix timestamp when signal was generated
        price: Current price when signal was generated
        stop_loss: Optional stop loss price
        take_profit: Optional take profit price
        position_size: Optional suggested position size
        reasoning: Optional human-readable explanation
        metadata: Optional additional signal data
    """
    ticker: str
    action: str  # 'BUY', 'SELL', or 'HOLD'
    confidence: float  # 0.0 to 1.0
    timestamp: Optional[float] = None
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    reasoning: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Post-initialization validation and defaults."""
        # Set timestamp if not provided
        if self.timestamp is None:
            self.timestamp = time.time()
        
        # Validate action
        if self.action not in ['BUY', 'SELL', 'HOLD']:
            raise ValueError(f"Invalid action: {self.action}. Must be 'BUY', 'SELL', or 'HOLD'")
        
        # Validate confidence
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Invalid confidence: {self.confidence}. Must be between 0.0 and 1.0")
        
        # Validate ticker
        if not self.ticker or not isinstance(self.ticker, str):
            raise ValueError("Ticker must be a non-empty string")
        
        # Initialize metadata if None
        if self.metadata is None:
            self.metadata = {}
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert signal to dictionary for serialization.
        
        Returns:
            Dictionary representation of the signal
        """
        return {
            'ticker': self.ticker,
            'action': self.action,
            'confidence': self.confidence,
            'timestamp': self.timestamp,
            'price': self.price,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'position_size': self.position_size,
            'reasoning': self.reasoning,
            'metadata': self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'TradingSignal':
        """
        Create signal from dictionary.
        
        Args:
            data: Dictionary containing signal data
            
        Returns:
            TradingSignal instance
        """
        return cls(**data)
    
    def is_actionable(self, min_confidence: float = 0.5) -> bool:
        """
        Check if signal is actionable based on confidence threshold.
        
        Args:
            min_confidence: Minimum confidence required
            
        Returns:
            True if signal should be acted upon, False otherwise
        """
        return (self.confidence >= min_confidence and 
                self.action in ['BUY', 'SELL'])
    
    def get_signal_strength(self) -> str:
        """
        Get human-readable signal strength based on confidence.
        
        Returns:
            Signal strength description
        """
        if self.confidence >= 0.9:
            return "VERY_STRONG"
        elif self.confidence >= 0.8:
            return "STRONG"
        elif self.confidence >= 0.7:
            return "MODERATE"
        elif self.confidence >= 0.6:
            return "WEAK"
        else:
            return "VERY_WEAK"
    
    def __str__(self) -> str:
        """String representation of signal."""
        return (f"TradingSignal({self.action} {self.ticker} @ {self.confidence:.2f} "
                f"confidence, price: ${self.price or 'N/A'})")
    
    def __repr__(self) -> str:
        """Detailed representation of signal."""
        return (f"TradingSignal(ticker='{self.ticker}', action='{self.action}', "
                f"confidence={self.confidence}, price={self.price})")


# Convenience functions for creating signals
def create_buy_signal(
    ticker: str,
    confidence: float,
    price: Optional[float] = None,
    stop_loss: Optional[float] = None,
    take_profit: Optional[float] = None,
    reasoning: Optional[str] = None,
    **kwargs
) -> TradingSignal:
    """
    Create a BUY signal with convenience parameters.
    
    Args:
        ticker: Stock symbol
        confidence: Confidence level (0.0 to 1.0)
        price: Current price
        stop_loss: Stop loss price
        take_profit: Take profit price
        reasoning: Signal explanation
        **kwargs: Additional metadata
        
    Returns:
        TradingSignal with BUY action
    """
    return TradingSignal(
        ticker=ticker,
        action="BUY",
        confidence=confidence,
        price=price,
        stop_loss=stop_loss,
        take_profit=take_profit,
        reasoning=reasoning,
        metadata=kwargs
    )


def create_sell_signal(
    ticker: str,
    confidence: float,
    price: Optional[float] = None,
    reasoning: Optional[str] = None,
    **kwargs
) -> TradingSignal:
    """
    Create a SELL signal with convenience parameters.
    
    Args:
        ticker: Stock symbol
        confidence: Confidence level (0.0 to 1.0)
        price: Current price
        reasoning: Signal explanation
        **kwargs: Additional metadata
        
    Returns:
        TradingSignal with SELL action
    """
    return TradingSignal(
        ticker=ticker,
        action="SELL",
        confidence=confidence,
        price=price,
        reasoning=reasoning,
        metadata=kwargs
    )


def create_hold_signal(
    ticker: str,
    confidence: float = 0.5,
    price: Optional[float] = None,
    reasoning: Optional[str] = None,
    **kwargs
) -> TradingSignal:
    """
    Create a HOLD signal with convenience parameters.
    
    Args:
        ticker: Stock symbol
        confidence: Confidence level (0.0 to 1.0)
        price: Current price
        reasoning: Signal explanation
        **kwargs: Additional metadata
        
    Returns:
        TradingSignal with HOLD action
    """
    return TradingSignal(
        ticker=ticker,
        action="HOLD",
        confidence=confidence,
        price=price,
        reasoning=reasoning,
        metadata=kwargs
    )


# Example usage and testing
if __name__ == "__main__":
    # Test signal creation
    signal1 = create_buy_signal(
        ticker="AAPL",
        confidence=0.85,
        price=150.00,
        stop_loss=140.00,
        take_profit=165.00,
        reasoning="Strong bullish momentum detected",
        model_type="RandomForest",
        feature_importance=0.92
    )
    
    print(f"Created signal: {signal1}")
    print(f"Signal strength: {signal1.get_signal_strength()}")
    print(f"Is actionable: {signal1.is_actionable(0.8)}")
    print(f"Signal dict: {signal1.to_dict()}")
    
    # Test signal validation
    try:
        invalid_signal = TradingSignal(
            ticker="",
            action="INVALID",
            confidence=1.5
        )
    except ValueError as e:
        print(f"✓ Validation caught error: {e}")
    
    # Test signal from dict
    signal_dict = {
        'ticker': 'MSFT',
        'action': 'SELL',
        'confidence': 0.75,
        'price': 300.00,
        'reasoning': 'Technical resistance level reached'
    }
    
    signal2 = TradingSignal.from_dict(signal_dict)
    print(f"Signal from dict: {signal2}")
    
    print("✓ All signal tests passed!")